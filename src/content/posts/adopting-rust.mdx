---
title: Ladybird adopts Rust, with help from AI
author: Andreas Kling
description: We're adopting Rust as our C++ successor language, and using AI agents to accelerate the transition.
image: /assets/img/plant.webp
type: Announcement
date: 2026-02-23
---

We've been searching for a memory-safe programming language to replace C++ in Ladybird for a while now. We previously explored Swift, but the C++ interop never quite got there, and platform support outside the Apple ecosystem was limited. Rust is a different story. The ecosystem is far more mature for systems programming, and many of our contributors already know the language. Going forward, we are rewriting parts of Ladybird in Rust.

### Why Rust?

When we originally evaluated Rust back in 2024, we rejected it because it's not great at C++ style OOP. The web platform object model inherits a lot of 1990s OOP flavor, with garbage collection, deep inheritance hierarchies, and so on. Rust's ownership model is not a natural fit for that.

But after another year of treading water, it's time to make the pragmatic choice. Rust has the ecosystem and the safety guarantees we need. Both Firefox and Chromium have already begun introducing Rust into their codebases, and we think it's the right choice for Ladybird too.

### Porting LibJS

Our first target was **LibJS**, Ladybird's JavaScript engine. The lexer, parser, AST, and bytecode generator are relatively self-contained and have extensive test coverage through [test262](https://github.com/tc39/test262), which made them a natural starting point.

I used [Claude Code](https://docs.anthropic.com/en/docs/claude-code) and [Codex](https://openai.com/codex/) for the translation. This was human-directed, not autonomous code generation. I decided what to port, in what order, and what the Rust code should look like. It was hundreds of small prompts, steering the agents where things needed to go. After the initial translation, I ran multiple passes of adversarial review, asking different models to analyze the code for mistakes and bad patterns.

### Results

The requirement from the start was byte-for-byte identical output from both pipelines. The result was about 25,000 lines of Rust, and the entire port took about two weeks. The same work would have taken me multiple months to do by hand. We've verified that every AST produced by the Rust parser is identical to the C++ one, and all bytecode generated by the Rust compiler is identical to the C++ compiler's output. Zero regressions across the board:

| Test suite                                 | Tests  | Regressions |
| ------------------------------------------ | ------ | ----------- |
| [test262](https://github.com/tc39/test262) | 52,898 | 0           |
| Ladybird regression tests                  | 12,461 | 0           |

No performance regressions on any of the JS benchmarks we track either.

Beyond the test suites, I've done extensive testing by browsing the web in a lockstep mode where both the C++ and Rust pipelines run simultaneously, verifying that output is identical for every piece of JavaScript that flows through them.

If you look at [the code](https://github.com/LadybirdBrowser/ladybird/pull/8104), you'll notice it has a strong "translated from C++" vibe. That's because it _is_ translated from C++. The top priority for this first pass is compatibility with our C++ pipeline. The Rust code intentionally mimics things like the C++ register allocation patterns so that the two compilers produce identical bytecode. Correctness is a close second. We know the result isn't idiomatic Rust, and there's a lot that can be simplified once we're comfortable retiring the C++ pipeline. That cleanup will come in time.

### What's next

This is not becoming the main focus of the project. We will continue developing the engine in C++, and porting subsystems to Rust will be a sidetrack that runs for a long time. New Rust code will coexist with existing C++ through well-defined interop boundaries.

We want to be deliberate about which parts get ported and in what order, so the porting effort is managed by the core team. Please coordinate with us before starting any porting work so nobody wastes their time on something we can't merge.

I know this will be a controversial move, but I believe it's the right decision for Ladybird's future. :^)

_Andreas Kling_

Founder & President
